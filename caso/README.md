# Objetivo y supuestos

Objetivo: usar los datos 2021 para proyectar demanda de aulas y docentes por programa y semestre, y generar un plan de recursos (nº aulas y docentes) por semestre para los próximos N semestres. Además dejar triggers que detecten sobrecarga de aulas cuando se inserte una matrícula nueva.

Supuestos:
- Cada fila del dataset = 1 matrícula
- Ratio docente-estudiantes por defecto: 1 docente por 30 estudiantes (puedes cambiarlo).
- Capacidad aula por defecto: 40 estudiantes (configurable).
- Proyección simple: uso de crecimiento lineal basado en últimas k semestres (aquí 2 semestres históricos disponibles — si no hay históricos, uso media).
- Usaremos semestres (p. ej. 2021-1, 2021-2) idénticos en el campo SEMESTRE INGRESO.

# Modelo de datos
```sql
-- 1. Tabla principal de matriculas (cada fila = 1 matrícula)
CREATE TABLE matriculas (
    MATRICULA_ID INTEGER PRIMARY KEY,
    GENERO_ID SMALLINT NOT NULL,
    EDAD SMALLINT NOT NULL,
    RANGO_EDAD_ID SMALLINT NOT NULL,
    ANIO_INGRESO SMALLINT NOT NULL,
    SEMESTRE_INGRESO SMALLINT NOT NULL,
    INSTITUCION_ID SMALLINT NOT NULL,
    CARRERA_ID SMALLINT NOT NULL,
    VIA_INGRESO_ID SMALLINT NOT NULL,
    COMUNA_ID SMALLINT NOT NULL
);

-- 2. Tabla para almacenar resultados / planes por programa y semestre proyectado
CREATE TABLE RECURSOS_PAN (
    RECURSO_PLAN_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    INSTITUCION_NOMBRE VARCHAR2(200),
    CARRERA_NOMBRE VARCHAR2(200),
    SEMESTRE VARCHAR2(20),
    ESTUDIANTES_PROYECTADOS NUMBER,
    PROFESORES_REQUERIDOS NUMBER,
    SALAS_REQUERIDAS NUMBER,
    CREATED_AT DATE DEFAULT SYSDATE,
    UPDATED_AT DATE DEFAULT SYSDATE
);

-- 3. Tabla de capacidad de infraestructura actual (datos de la institución)
CREATE TABLE CAPACIDADES_INSTITUCION (
  INSTITUCION_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  INSTITUCION_NOMBRE VARCHAR2(200) UNIQUE,
  SALAS_TOTALES NUMBER,
  CAPACIDAD_SALA NUMBER,
  PROFESORES_POOL NUMBER 
);
```

# Tipos (VARRAY / RECORD) y justificación

VARRAY `sem_proj_t` para almacenar proyección por los próximos N semestres (vector compacto dentro de una columna o variable). Útil para devolver una proyección de N semestres en una sola llamada de procedure/function.

RECORD `prog_summary_rec` para mantener en memoria la información agregada de un programa (nombre, semestres, conteos, ratios) durante la ejecución del planificador.

```SQL
-- VARRAY para proyección (p. ej. 8 semestres = 4 años)
CREATE OR REPLACE TYPE sem_proj_t AS VARRAY(8) OF NUMBER;
/
```

# Funciones y procedimientos (PL/SQL)

A continuación un conjunto de objetos PL/SQL que implementan la lógica de planificación:
- `teachers_needed` — función que devuelve docentes requeridos.
- `classrooms_needed` — función que devuelve aulas necesarias.
- `project_students_for_next_semesters` — función simple que devuelve un sem_proj_t con proyección lineal usando últimos 2 semestres.
- `build_resource_plan` — procedimiento que recorre (cursor explícito) programas y crea filas en resource_plan.
- `trg_check_capacity_before_insert` — trigger que evita insertar matrícula si institución no tiene aulas disponibles para ese semestre (ejemplo de trigger).

```SQL
-- 1) Función: cantidad docentes requeridos
CREATE OR REPLACE FUNCTION teachers_needed(p_students NUMBER, p_ratio NUMBER DEFAULT 30) RETURN NUMBER IS
BEGIN
  IF p_students IS NULL OR p_students <= 0 THEN
    RETURN 0;
  ELSE
    RETURN CEIL(p_students / NVL(p_ratio,30));
  END IF;
END teachers_needed;
/

-- 2) Función: aulas necesarias
CREATE OR REPLACE FUNCTION classrooms_needed(p_students NUMBER, p_classroom_capacity NUMBER DEFAULT 40) RETURN NUMBER IS
BEGIN
  IF p_students IS NULL OR p_students <= 0 THEN
    RETURN 0;
  ELSE
    RETURN CEIL(p_students / NVL(p_classroom_capacity,40));
  END IF;
END classrooms_needed;
/

-- 3) Proyección simple por semestres (usa últimos 2 semestres históricos para calcular crecimiento)
CREATE OR REPLACE FUNCTION project_students_for_next_semesters(
  p_institution VARCHAR2,
  p_career VARCHAR2,
  p_next_n NUMBER DEFAULT 4 -- cuántos semestres proyectar
) RETURN sem_proj_t IS
  v_result sem_proj_t := sem_proj_t();
  v_last_sem VARCHAR2(20);
  v_count_last NUMBER := 0;
  v_count_prev NUMBER := 0;
  v_growth_rate NUMBER := 0;
  CURSOR c_last_two IS
    SELECT SEMESTRE_INGRESO, COUNT(*) cnt
    FROM MATRICULAS
    WHERE INSTITUCION_ID = p_institution
      AND CARRERA_ID = p_career
    GROUP BY SEMESTRE_INGRESO
    ORDER BY SEMESTRE_INGRESO DESC;
  TYPE arr_t IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  v_counts arr_t;
  idx PLS_INTEGER := 0;
BEGIN
  FOR r IN c_last_two LOOP
    idx := idx + 1;
    v_counts(idx) := r.cnt;
    EXIT WHEN idx = 2; -- solo queremos 2 últimos semestres
  END LOOP;

  IF idx = 0 THEN
    -- sin historial: retornamos ceros
    FOR i IN 1..p_next_n LOOP v_result.EXTEND; v_result(i) := 0; END LOOP;
    RETURN v_result;
  ELSIF idx = 1 THEN
    -- solo 1 histórico: repetimos el valor
    FOR i IN 1..p_next_n LOOP v_result.EXTEND; v_result(i) := v_counts(1); END LOOP;
    RETURN v_result;
  ELSE
    v_count_last := v_counts(1);
    v_count_prev := v_counts(2);
    IF v_count_prev = 0 THEN
      v_growth_rate := 0;
    ELSE
      v_growth_rate := (v_count_last - v_count_prev) / v_count_prev; -- tasa simple
    END IF;
    -- generar p_next_n semestres con crecimiento lineal compuesto (aprox)
    FOR i IN 1..p_next_n LOOP
      v_result.EXTEND;
      IF i = 1 THEN
        v_result(i) := ROUND(v_count_last * (1 + v_growth_rate));
      ELSE
        v_result(i) := ROUND(v_result(i-1) * (1 + v_growth_rate));
      END IF;
    END LOOP;
    RETURN v_result;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    -- en caso de error, devuelvo ceros
    v_result := sem_proj_t();
    FOR i IN 1..p_next_n LOOP v_result.EXTEND; v_result(i) := 0; END LOOP;
    RETURN v_result;
END project_students_for_next_semesters;
/

-- 4) Procedure: recorre programas y genera plan por semestre (usa cursor explícito y RECORD)
CREATE OR REPLACE PROCEDURE build_resource_plan(p_next_n NUMBER DEFAULT 4) IS

  -- Record para resumen de programa
  TYPE prog_summary_rec IS RECORD (
    institucion_id MATRICULAS.INSTITUCION_ID%TYPE,
    carrera_id MATRICULAS.CARRERA_ID%TYPE
  );

  CURSOR c_programs IS
    SELECT DISTINCT INSTITUCION_ID, CARRERA_ID
    FROM MATRICULAS;

  v_prog prog_summary_rec;
  v_proj sem_proj_t;
  v_sem_label VARCHAR2(20);

  -- helpers
  v_teachers NUMBER;
  v_classrooms NUMBER;
  v_semeste_base VARCHAR2(20); -- base temporal para crear etiquetas
  v_current_year NUMBER := TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'));
  v_current_month NUMBER := TO_NUMBER(TO_CHAR(SYSDATE,'MM'));

  -- exception
  e_no_history EXCEPTION;

BEGIN
  OPEN c_programs;
  LOOP
    FETCH c_programs INTO v_prog.institucion_id, v_prog.carrera_id;
    EXIT WHEN c_programs%NOTFOUND;

    -- obtener proyección vectorial
    v_proj := project_students_for_next_semesters(v_prog.institucion_id, v_prog.carrera_id, p_next_n);

    -- iterar proyección por cada semestre proyectado
    FOR i IN 1..p_next_n LOOP
      -- Formar etiqueta de semestre objetivo (ejemplo: calculo simple: si estamos en semestre 1 -> siguiente 2, etc)
      -- Aquí generamos 'YYYY-1' o 'YYYY-2' de forma simple.
      DECLARE
        sem_num NUMBER;
        year_num NUMBER := v_current_year;
      BEGIN
        -- determinamos semestre actual aproximado: mes<=6 -> semestre 1, else 2
        IF v_current_month <= 6 THEN
          sem_num := 1 + i; -- semestres próximos
        ELSE
          sem_num := 2 + i;
        END IF;
        -- normalizar sem_num a formato semestral (1 o 2) y ajustar año
        WHILE sem_num > 2 LOOP
          sem_num := sem_num - 2;
          year_num := year_num + 1;
        END LOOP;
        v_sem_label := TO_CHAR(year_num) || '-' || TO_CHAR(sem_num);
      END;

      -- calcular recursos
      v_teachers := teachers_needed(v_proj(i), 30); -- ratio por defecto 30
      v_classrooms := classrooms_needed(v_proj(i), 40); -- capacidad por defecto 40

      -- insertar/actualizar plan
      INSERT INTO resource_plan (nombre_institucion, nombre_carrera, semestre, projected_students, required_teachers, required_classrooms)
      VALUES (v_prog.institucion_id, v_prog.carrera_id, v_sem_label, v_proj(i), v_teachers, v_classrooms);
    END LOOP;

  END LOOP;
  CLOSE c_programs;

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error en build_resource_plan: ' || SQLERRM);
    ROLLBACK;
END build_resource_plan;
/
```

# Trigger: control de capacidad al insertar una matrícula nueva

Este trigger BEFORE INSERT revisa la capacidad registrada en `institution_capacity` para la institución y compara aulas necesarias calculadas con aulas disponibles. Si excede, lanza error con `RAISE_APPLICATION_ERROR`. Esto demuestra manejo de excepciones y reglas de negocio centralizadas.

```SQL
CREATE OR REPLACE TRIGGER trg_check_capacity_before_insert
BEFORE INSERT ON MATRICULAS
FOR EACH ROW
DECLARE
  v_total_students NUMBER;
  v_required_classrooms NUMBER;
  v_avail_classrooms NUMBER;
  v_inst_id NUMBER;
  v_institution VARCHAR2(200) := :NEW.nombre_institucion;
BEGIN
  -- contar alumnos ya asignados para el mismo semestre + la nueva matrícula
  SELECT COUNT(*) INTO v_total_students
  FROM MATRICULAS m
  WHERE m.INSTITUCION_ID = v_institution
    AND m.SEMESTRE_INGRESO = :NEW.SEMESTRE_INGRESO;

  v_total_students := v_total_students + 1; -- incluida la nueva

  -- obtener capacidad
  SELECT total_classrooms INTO v_avail_classrooms
  FROM CAPACIDADES_INSTITUCION ic
  WHERE ci.INSTITUCION_ID = v_institution
  FOR UPDATE NOWAIT;

  -- calcular aulas necesarias
  v_required_classrooms := classrooms_needed(v_total_students, (SELECT classroom_capacity FROM institution_capacity WHERE nombre_institucion = v_institution));

  IF v_required_classrooms > v_avail_classrooms THEN
    -- bloqueamos la inserción y mandamos mensaje con detalle
    RAISE_APPLICATION_ERROR(-20010, 'Capacidad insuficiente en '||v_institution||' para semestre '||:NEW.semestre_ingreso||
                                '. Aulas requeridas='||v_required_classrooms||', disponibles='||v_avail_classrooms);
  END IF;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- Si no hay datos de capacidad, permitimos la inserción pero la registramos en output
    DBMS_OUTPUT.PUT_LINE('No hay registro de capacidad para ' || v_institution || '. Inserción permitida por defecto.');
  WHEN OTHERS THEN
    -- si FOR UPDATE falla por bloqueo o cualquier otro error, dejamos pasar o bloqueamos según política
    DBMS_OUTPUT.PUT_LINE('Trigger capacity error: ' || SQLERRM);
    -- opcional: RAISE; -- para bloquear la inserción en caso de error crítico
END;
/
```

# Flujo de trabajo / ejecución sugerida y ejemplos de uso

1. Cargar el Excel a MATRICULAS (CSV load o SQL Developer import).  Luego verificar con SELECT COUNT(*) FROM MATRICULAS; que los conteos concuerden.
2. Definir capacidad institucional (ejemplo):
```SQL
INSERT INTO institution_capacity (nombre_institucion, total_classrooms, classroom_capacity, teacher_pool)
VALUES ('Universidad Ejemplo', 20, 40, 120);
COMMIT;
```
3. Generar plan de recursos:
```SQL
BEGIN
  build_resource_plan(4); -- proyecta próximos 4 semestres
END;
/
```
4. Revisar resultados:
```SQL
SELECT nombre_institucion, nombre_carrera, semestre, projected_students, required_teachers, required_classrooms
FROM resource_plan
ORDER BY nombre_institucion, nombre_carrera, semestre;
``` 
5. Probar trigger: intentar insertar una matrícula extra en una institución que supere la capacidad para ver la excepción.
```SQL
INSERT INTO raw_enrollments (semestre_ingreso, nombre_institucion, nombre_carrera, modalidad, jornada, region_sede)
VALUES ('2022-1', 'Universidad Ejemplo', 'Ingeniería Informática', 'Presencial', 'Diurna', 'Región X');
-- Si excede aulas, obtendrás el error RAISE_APPLICATION_ERROR con el mensaje legible.
```

# Consideraciones técnicas y mejoras posibles

- Mejor proyección: sustituir la función project_students_for_next_semesters por regresión lineal, promedio móvil o modelos más robustos si tienes varios semestres históricos.
- Granularidad temporal: hoy usamos semestres; podrías usar periodos más finos si tu dataset incluye meses.
- Asignación por jornada y modalidad: los ratio aula/docente pueden variar (ej.: modalidad vespertina necesita más aulas por solapamiento). Podrías extender las funciones para considerar modalidad y jornada.
- Bloqueo y concurrencia: trigger usa FOR UPDATE NOWAIT en institution_capacity — contempla manejo de bloqueos en entornos concurrentes.
- Auditoría: crear tabla resource_plan_history y triggers que registren cambios y razones.
- UI / Dashboard: exportar resource_plan a herramienta visual (Power BI / Tableau) para ver heatmaps por comuna/provincia/región.