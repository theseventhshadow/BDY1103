# Sistema de Proyección de Recursos Educativos

## Objetivo y supuestos

Objetivo: usar los datos 2021 para proyectar demanda de aulas y docentes por programa y semestre, y generar un plan de recursos (nº aulas y docentes) por semestre para los próximos N semestres. Además dejar triggers que detecten sobrecarga de aulas cuando se inserte una matrícula nueva.

Supuestos:
- Cada fila del dataset = 1 matrícula
- Ratio docente-estudiantes por defecto: 1 docente por 30 estudiantes (puedes cambiarlo).
- Capacidad aula por defecto: 40 estudiantes (configurable).
- Proyección simple: uso de crecimiento lineal basado en últimas k semestres (aquí 2 semestres históricos disponibles — si no hay históricos, uso media).
- Usaremos semestres (p. ej. 2021-1, 2021-2) idénticos en el campo SEMESTRE INGRESO.

## Package PKG_PROYECCION_RECURSOS

Este proyecto incluye un **package completo** que encapsula toda la funcionalidad de proyección de recursos educativos, proporcionando una interfaz unificada y manejo robusto de errores.

### Instalación Rápida

```sql
-- 1. Instalar el package completo (incluye VARRAY dinámico y trigger)
@install_package.sql

-- 2. Ejecutar ejemplos de uso
@ejemplos_package.sql

-- 3. Probar funcionalidad específica del VARRAY
@ejemplos_varray_integrado.sql
```

### Características Principales

- ✅ **Encapsulación completa**: Todas las funciones y procedimientos organizados en un package
- ✅ **VARRAY dinámico**: Creación automática basada en duración real de carreras
- ✅ **Trigger integrado**: Verificación de capacidad usando funciones del package
- ✅ **Manejo robusto de errores**: Sistema de logging centralizado y excepciones personalizadas
- ✅ **Cache inteligente**: Optimización de consultas frecuentes
- ✅ **Funciones pipelined**: Consultas flexibles como tabla virtual
- ✅ **Configuración por defecto**: Valores predeterminados personalizables
- ✅ **Validación automática**: Verificación de parámetros y existencia de datos
- ✅ **Sistema de logging**: Trazabilidad completa de operaciones y errores
- ✅ **Instalación unificada**: Un solo script instala todo el sistema

# Modelo de datos
```sql
-- 1. Tabla principal de matriculas (cada fila = 1 matrícula)
CREATE TABLE matriculas (
    MATRICULA_ID INTEGER PRIMARY KEY,
    GENERO_ID SMALLINT NOT NULL,
    EDAD SMALLINT NOT NULL,
    RANGO_EDAD_ID SMALLINT NOT NULL,
    ANIO_INGRESO SMALLINT NOT NULL,
    SEMESTRE_INGRESO SMALLINT NOT NULL,
    INSTITUCION_ID SMALLINT NOT NULL,
    CARRERA_ID SMALLINT NOT NULL,
    VIA_INGRESO_ID SMALLINT NOT NULL,
    COMUNA_ID SMALLINT NOT NULL
);

-- 2. Tabla para almacenar resultados / planes por programa y semestre proyectado
CREATE TABLE RECURSOS_PAN (
    RECURSO_PLAN_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    INSTITUCION_NOMBRE VARCHAR2(200),
    CARRERA_NOMBRE VARCHAR2(200),
    SEMESTRE VARCHAR2(20),
    ESTUDIANTES_PROYECTADOS NUMBER,
    PROFESORES_REQUERIDOS NUMBER,
    SALAS_REQUERIDAS NUMBER,
    CREATED_AT DATE DEFAULT SYSDATE,
    UPDATED_AT DATE DEFAULT SYSDATE
);

-- 3. Tabla de capacidad de infraestructura actual (datos de la institución)
CREATE TABLE CAPACIDADES_INSTITUCION (
  INSTITUCION_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  INSTITUCION_NOMBRE VARCHAR2(200) UNIQUE,
  SALAS_TOTALES NUMBER,
  CAPACIDAD_SALA NUMBER,
  PROFESORES_POOL NUMBER 
);
```

# Tipos (VARRAY / RECORD) y justificación

VARRAY `sem_proj_t` para almacenar proyección por los próximos N semestres (vector compacto dentro de una columna o variable). Útil para devolver una proyección de N semestres en una sola llamada de procedure/function.

RECORD `prog_summary_rec` para mantener en memoria la información agregada de un programa (nombre, semestres, conteos, ratios) durante la ejecución del planificador.

```SQL
-- VARRAY para proyección (p. ej. 8 semestres = 4 años)
CREATE OR REPLACE TYPE sem_proj_t AS VARRAY(8) OF NUMBER;
/
```

# Funciones y procedimientos (PL/SQL)

A continuación un conjunto de objetos PL/SQL que implementan la lógica de planificación:
- `teachers_needed` — función que devuelve docentes requeridos.
- `classrooms_needed` — función que devuelve aulas necesarias.
- `project_students_for_next_semesters` — función simple que devuelve un sem_proj_t con proyección lineal usando últimos 2 semestres.
- `build_resource_plan` — procedimiento que recorre (cursor explícito) programas y crea filas en resource_plan.
- `trg_check_capacity_before_insert` — trigger que evita insertar matrícula si institución no tiene aulas disponibles para ese semestre (ejemplo de trigger).

```SQL
-- 1) Función: cantidad docentes requeridos
CREATE OR REPLACE FUNCTION teachers_needed(p_students NUMBER, p_ratio NUMBER DEFAULT 30) RETURN NUMBER IS
BEGIN
  IF p_students IS NULL OR p_students <= 0 THEN
    RETURN 0;
  ELSE
    RETURN CEIL(p_students / NVL(p_ratio,30));
  END IF;
END teachers_needed;
/

-- 2) Función: aulas necesarias
CREATE OR REPLACE FUNCTION classrooms_needed(p_students NUMBER, p_classroom_capacity NUMBER DEFAULT 40) RETURN NUMBER IS
BEGIN
  IF p_students IS NULL OR p_students <= 0 THEN
    RETURN 0;
  ELSE
    RETURN CEIL(p_students / NVL(p_classroom_capacity,40));
  END IF;
END classrooms_needed;
/

-- 3) Proyección simple por semestres (usa últimos 2 semestres históricos para calcular crecimiento)
CREATE OR REPLACE FUNCTION project_students_for_next_semesters(
  p_institution VARCHAR2,
  p_career VARCHAR2,
  p_next_n NUMBER DEFAULT 4 -- cuántos semestres proyectar
) RETURN sem_proj_t IS
  v_result sem_proj_t := sem_proj_t();
  v_last_sem VARCHAR2(20);
  v_count_last NUMBER := 0;
  v_count_prev NUMBER := 0;
  v_growth_rate NUMBER := 0;
  CURSOR c_last_two IS
    SELECT SEMESTRE_INGRESO, COUNT(*) cnt
    FROM MATRICULAS
    WHERE INSTITUCION_ID = p_institution
      AND CARRERA_ID = p_career
    GROUP BY SEMESTRE_INGRESO
    ORDER BY SEMESTRE_INGRESO DESC;
  TYPE arr_t IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  v_counts arr_t;
  idx PLS_INTEGER := 0;
BEGIN
  FOR r IN c_last_two LOOP
    idx := idx + 1;
    v_counts(idx) := r.cnt;
    EXIT WHEN idx = 2; -- solo queremos 2 últimos semestres
  END LOOP;

  IF idx = 0 THEN
    -- sin historial: retornamos ceros
    FOR i IN 1..p_next_n LOOP v_result.EXTEND; v_result(i) := 0; END LOOP;
    RETURN v_result;
  ELSIF idx = 1 THEN
    -- solo 1 histórico: repetimos el valor
    FOR i IN 1..p_next_n LOOP v_result.EXTEND; v_result(i) := v_counts(1); END LOOP;
    RETURN v_result;
  ELSE
    v_count_last := v_counts(1);
    v_count_prev := v_counts(2);
    IF v_count_prev = 0 THEN
      v_growth_rate := 0;
    ELSE
      v_growth_rate := (v_count_last - v_count_prev) / v_count_prev; -- tasa simple
    END IF;
    -- generar p_next_n semestres con crecimiento lineal compuesto (aprox)
    FOR i IN 1..p_next_n LOOP
      v_result.EXTEND;
      IF i = 1 THEN
        v_result(i) := ROUND(v_count_last * (1 + v_growth_rate));
      ELSE
        v_result(i) := ROUND(v_result(i-1) * (1 + v_growth_rate));
      END IF;
    END LOOP;
    RETURN v_result;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    -- en caso de error, devuelvo ceros
    v_result := sem_proj_t();
    FOR i IN 1..p_next_n LOOP v_result.EXTEND; v_result(i) := 0; END LOOP;
    RETURN v_result;
END project_students_for_next_semesters;
/

-- 4) Procedure: recorre programas y genera plan por semestre (usa cursor explícito y RECORD)
CREATE OR REPLACE PROCEDURE build_resource_plan(p_next_n NUMBER DEFAULT 4) IS

  -- Record para resumen de programa
  TYPE prog_summary_rec IS RECORD (
    institucion_id MATRICULAS.INSTITUCION_ID%TYPE,
    carrera_id MATRICULAS.CARRERA_ID%TYPE
  );

  CURSOR c_programs IS
    SELECT DISTINCT INSTITUCION_ID, CARRERA_ID
    FROM MATRICULAS;

  v_prog prog_summary_rec;
  v_proj sem_proj_t;
  v_sem_label VARCHAR2(20);

  -- helpers
  v_teachers NUMBER;
  v_classrooms NUMBER;
  v_semeste_base VARCHAR2(20); -- base temporal para crear etiquetas
  v_current_year NUMBER := TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'));
  v_current_month NUMBER := TO_NUMBER(TO_CHAR(SYSDATE,'MM'));

  -- exception
  e_no_history EXCEPTION;

BEGIN
  OPEN c_programs;
  LOOP
    FETCH c_programs INTO v_prog.institucion_id, v_prog.carrera_id;
    EXIT WHEN c_programs%NOTFOUND;

    -- obtener proyección vectorial
    v_proj := project_students_for_next_semesters(v_prog.institucion_id, v_prog.carrera_id, p_next_n);

    -- iterar proyección por cada semestre proyectado
    FOR i IN 1..p_next_n LOOP
      -- Formar etiqueta de semestre objetivo (ejemplo: calculo simple: si estamos en semestre 1 -> siguiente 2, etc)
      -- Aquí generamos 'YYYY-1' o 'YYYY-2' de forma simple.
      DECLARE
        sem_num NUMBER;
        year_num NUMBER := v_current_year;
      BEGIN
        -- determinamos semestre actual aproximado: mes<=6 -> semestre 1, else 2
        IF v_current_month <= 6 THEN
          sem_num := 1 + i; -- semestres próximos
        ELSE
          sem_num := 2 + i;
        END IF;
        -- normalizar sem_num a formato semestral (1 o 2) y ajustar año
        WHILE sem_num > 2 LOOP
          sem_num := sem_num - 2;
          year_num := year_num + 1;
        END LOOP;
        v_sem_label := TO_CHAR(year_num) || '-' || TO_CHAR(sem_num);
      END;

      -- calcular recursos
      v_teachers := teachers_needed(v_proj(i), 30); -- ratio por defecto 30
      v_classrooms := classrooms_needed(v_proj(i), 40); -- capacidad por defecto 40

      -- insertar/actualizar plan
      INSERT INTO resource_plan (nombre_institucion, nombre_carrera, semestre, projected_students, required_teachers, required_classrooms)
      VALUES (v_prog.institucion_id, v_prog.carrera_id, v_sem_label, v_proj(i), v_teachers, v_classrooms);
    END LOOP;

  END LOOP;
  CLOSE c_programs;

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error en build_resource_plan: ' || SQLERRM);
    ROLLBACK;
END build_resource_plan;
/
```

# Trigger: control de capacidad al insertar una matrícula nueva

Este trigger BEFORE INSERT revisa la capacidad registrada en `institution_capacity` para la institución y compara aulas necesarias calculadas con aulas disponibles. Si excede, lanza error con `RAISE_APPLICATION_ERROR`. Esto demuestra manejo de excepciones y reglas de negocio centralizadas.

```SQL
CREATE OR REPLACE TRIGGER trg_check_capacity_before_insert
BEFORE INSERT ON MATRICULAS
FOR EACH ROW
DECLARE
  v_total_students NUMBER;
  v_required_classrooms NUMBER;
  v_avail_classrooms NUMBER;
  v_inst_id NUMBER;
  v_institution VARCHAR2(200) := :NEW.nombre_institucion;
BEGIN
  -- contar alumnos ya asignados para el mismo semestre + la nueva matrícula
  SELECT COUNT(*) INTO v_total_students
  FROM MATRICULAS m
  WHERE m.INSTITUCION_ID = v_institution
    AND m.SEMESTRE_INGRESO = :NEW.SEMESTRE_INGRESO;

  v_total_students := v_total_students + 1; -- incluida la nueva

  -- obtener capacidad
  SELECT total_classrooms INTO v_avail_classrooms
  FROM CAPACIDADES_INSTITUCION ic
  WHERE ci.INSTITUCION_ID = v_institution
  FOR UPDATE NOWAIT;

  -- calcular aulas necesarias
  v_required_classrooms := classrooms_needed(v_total_students, (SELECT classroom_capacity FROM institution_capacity WHERE nombre_institucion = v_institution));

  IF v_required_classrooms > v_avail_classrooms THEN
    -- bloqueamos la inserción y mandamos mensaje con detalle
    RAISE_APPLICATION_ERROR(-20010, 'Capacidad insuficiente en '||v_institution||' para semestre '||:NEW.semestre_ingreso||
                                '. Aulas requeridas='||v_required_classrooms||', disponibles='||v_avail_classrooms);
  END IF;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- Si no hay datos de capacidad, permitimos la inserción pero la registramos en output
    DBMS_OUTPUT.PUT_LINE('No hay registro de capacidad para ' || v_institution || '. Inserción permitida por defecto.');
  WHEN OTHERS THEN
    -- si FOR UPDATE falla por bloqueo o cualquier otro error, dejamos pasar o bloqueamos según política
    DBMS_OUTPUT.PUT_LINE('Trigger capacity error: ' || SQLERRM);
    -- opcional: RAISE; -- para bloquear la inserción en caso de error crítico
END;
/
```

## Estructura del Package

### Archivos Principales

- `package_spec.sql` - Especificación del package (interfaz pública)
- `package_body.sql` - Implementación del package (lógica interna)
- `install_package.sql` - Script de instalación automática
- `ejemplos_package.sql` - Ejemplos de uso y casos prácticos
- `ejemplos_varray_integrado.sql` - Ejemplos específicos del VARRAY dinámico
- `trigger_integrado.sql` - Trigger simplificado que usa el package
- `test_trigger_integrado.sql` - Pruebas completas del trigger

### Archivos de Referencia (mantenidos por compatibilidad)

- `varray.sql` - Versión original del VARRAY (ya no necesario)
- `trigger.sql` - Versión original del trigger (reemplazado por versión integrada)
- Archivos individuales de funciones (ahora integrados en el package)

### Elementos del Package

#### Tipos de Datos
```sql
TYPE t_proyeccion_detalle IS RECORD (...);  -- Estructura de proyección
TYPE t_proyecciones_tabla IS TABLE OF ...;  -- Tabla de proyecciones
proy_sem_t VARRAY(...) OF NUMBER;          -- Array dinámico de semestres
```

#### VARRAY Dinámico Integrado
```sql
-- Funciones para manejo automático del VARRAY
get_max_duracion_carreras() RETURN NUMBER;           -- Obtiene tamaño óptimo
verificar_varray_existente() RETURN BOOLEAN;         -- Verifica existencia
crear_varray_dinamico();                             -- Crea/recrea automáticamente
```

#### Integración con Triggers
```sql
-- Procedimiento usado por trigger para verificar capacidad
verificar_capacidad_matricula(p_institucion_id, p_carrera_id, p_anio_ingreso, p_semestre_ingreso)
```

#### Constantes Públicas
```sql
C_DEFAULT_STUDENT_TEACHER_RATIO := 30;     -- Ratio estudiante-profesor
C_DEFAULT_CLASSROOM_CAPACITY := 40;        -- Capacidad por aula
C_MAX_PROYECCION_SEMESTERS := 20;          -- Máximo semestres a proyectar
```

#### Funciones Principales
```sql
-- Proyección de estudiantes
proyeccion_estudiantes_para_prox_semestres(p_institucion_id, p_carrera_id, p_next_n)

-- Cálculo de recursos
profs_req(p_estudiantes, p_razon)
classrooms_needed(p_estudiantes, p_sala_capacidad)

-- Validación de datos
institucion_exists(p_institucion_id)
carrera_exists(p_carrera_id)

-- Utilidades
log_error(p_severity, p_source_obj, p_error_msg)
get_package_stats()
```

#### Procedimientos Principales
```sql
-- Generar plan completo de recursos
build_plan_recursos(p_next_n, p_institucion_id, p_carrera_id, p_region_id)

-- Verificar capacidad (usado por trigger)
verificar_capacidad_matricula(p_institucion_id, p_carrera_id, p_anio_ingreso, p_semestre_ingreso)

-- Mantenimiento
limpiar_planes_antiguos(p_dias_antiguedad)
generar_reporte_capacidad(p_institucion_id, p_mostrar_detalles)
```

#### Funciones Pipelined
```sql
-- Obtener proyecciones como tabla virtual
get_proyecciones_tabla(p_institucion_id, p_carrera_id, p_next_n)
```

## Flujo de trabajo / ejecución sugerida

### 1. Instalación
```sql
-- Instalar package completo
@install_package.sql
```

### 2. Configuración inicial
```sql
-- Configurar capacidades institucionales
INSERT INTO INSTITUCION_CAPACIDAD (INSTITUCION_ID, TOTAL_AULAS, CAPACIDAD_POR_AULA, DOCENTES_DISPONIBLES)
VALUES (1, 20, 40, 120);

-- Verificar instalación
SELECT PKG_PROYECCION_RECURSOS.get_package_stats() FROM DUAL;
```

### 3. Generar proyecciones
```sql
-- Plan completo para todas las instituciones
PKG_PROYECCION_RECURSOS.build_plan_recursos(6);

-- Plan específico para una institución
PKG_PROYECCION_RECURSOS.build_plan_recursos(
  p_next_n => 4,
  p_institucion_id => 1,
  p_carrera_id => NULL,
  p_region_id => NULL
);
```

### 4. Consultar resultados
```sql
-- Ver resumen por semestre
SELECT SEMESTRE_LABEL, COUNT(*) as combinaciones, 
       SUM(ESTUDIANTES_PROYECTADOS) as total_estudiantes
FROM PLANES_RECURSOS 
GROUP BY SEMESTRE_LABEL ORDER BY SEMESTRE_LABEL;

-- Usar función pipelined para consultas flexibles
SELECT * FROM TABLE(PKG_PROYECCION_RECURSOS.get_proyecciones_tabla(
  p_next_n => 4
)) WHERE estudiantes_proyectados > 100;

-- Generar reporte de capacidad
BEGIN
  PKG_PROYECCION_RECURSOS.generar_reporte_capacidad();
END;
/
```

### 5. Probar trigger integrado
```sql
-- Ejecutar pruebas del trigger
@test_trigger_integrado.sql

-- El trigger automáticamente verifica capacidad al insertar matrículas
-- usando el procedimiento del package
```

### 6. Mantenimiento
```sql
-- Limpiar planes antiguos (más de 30 días)
PKG_PROYECCION_RECURSOS.limpiar_planes_antiguos(30);

-- Ver log de errores
SELECT * FROM ERROR_LOG 
WHERE CREATED_AT >= SYSDATE - 1 
ORDER BY CREATED_AT DESC;
```

## Trigger Integrado con Package

El sistema incluye un **trigger simplificado** que utiliza el package para verificar capacidad:

### Trigger Original vs Trigger Integrado

| Aspecto | Trigger Original | Trigger Integrado |
|---------|------------------|-------------------|
| **Líneas de código** | ~400 líneas | ~10 líneas |
| **Lógica** | Duplicada en trigger | Centralizada en package |
| **Mantenimiento** | Difícil de modificar | Cambios en package |
| **Testing** | Requiere insertar datos | Se puede probar directamente |
| **Debugging** | Limitado en triggers | Full debugging en package |
| **Logging** | Sistema propio | Sistema unificado |
| **Reutilización** | Solo en trigger | Disponible en todo el package |

### Archivos del Trigger Integrado

- `trigger_integrado.sql` - Trigger simplificado que usa el package
- `test_trigger_integrado.sql` - Pruebas completas del trigger
- `trigger.sql` - Versión original (mantenida para referencia)

## Ventajas del Package vs Archivos Separados

| Aspecto | Archivos Separados | Package |
|---------|-------------------|---------|
| **Organización** | Disperso en múltiples archivos | Unificado en una estructura |
| **Mantenimiento** | Difícil de mantener coherencia | Cambios centralizados |
| **Rendimiento** | Carga individual de objetos | Carga única en memoria |
| **Encapsulación** | Todo público | Elementos públicos/privados |
| **Gestión de errores** | Manejo inconsistente | Sistema unificado de logging |
| **Dependencias** | Orden manual de ejecución | Resuelto automáticamente |
| **Reutilización** | Duplicación de código | Funciones compartidas |
| **Debugging** | Múltiples puntos de fallo | Trazabilidad centralizada |
| **Triggers** | Lógica duplicada | Lógica reutilizada |
| **VARRAY** | Archivo separado, tamaño fijo | Integrado, tamaño dinámico |

## Ejemplos de uso prácticos

Ver archivo `ejemplos_package.sql` para casos de uso detallados incluyendo:
- Proyecciones específicas por institución/carrera
- Cálculos de recursos personalizados  
- Validación de datos
- Consultas con funciones pipelined
- Generación de reportes
- Mantenimiento y limpieza de datos
BEGIN
  build_resource_plan(4); -- proyecta próximos 4 semestres
END;
/
```
4. Revisar resultados:
```SQL
SELECT nombre_institucion, nombre_carrera, semestre, projected_students, required_teachers, required_classrooms
FROM resource_plan
ORDER BY nombre_institucion, nombre_carrera, semestre;
``` 
5. Probar trigger: intentar insertar una matrícula extra en una institución que supere la capacidad para ver la excepción.
```SQL
INSERT INTO raw_enrollments (semestre_ingreso, nombre_institucion, nombre_carrera, modalidad, jornada, region_sede)
VALUES ('2022-1', 'Universidad Ejemplo', 'Ingeniería Informática', 'Presencial', 'Diurna', 'Región X');
-- Si excede aulas, obtendrás el error RAISE_APPLICATION_ERROR con el mensaje legible.
```

# Consideraciones técnicas y mejoras posibles

- Mejor proyección: sustituir la función project_students_for_next_semesters por regresión lineal, promedio móvil o modelos más robustos si tienes varios semestres históricos.
- Granularidad temporal: hoy usamos semestres; podrías usar periodos más finos si tu dataset incluye meses.
- Asignación por jornada y modalidad: los ratio aula/docente pueden variar (ej.: modalidad vespertina necesita más aulas por solapamiento). Podrías extender las funciones para considerar modalidad y jornada.
- Bloqueo y concurrencia: trigger usa FOR UPDATE NOWAIT en institution_capacity — contempla manejo de bloqueos en entornos concurrentes.
- Auditoría: crear tabla resource_plan_history y triggers que registren cambios y razones.
- UI / Dashboard: exportar resource_plan a herramienta visual (Power BI / Tableau) para ver heatmaps por comuna/provincia/región.